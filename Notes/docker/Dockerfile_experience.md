# Dockerfile 最佳实践

### 1、挑选合适的基础镜像

基础镜像尽量选最小的镜像，如 `busybox`,`alpine` 等。使用的时候一定要指定有版本号的镜像。<br>
如果是对系统没有过深入学习的可使用比较成熟的基础镜像，如 `Ubuntu`,`Centos` 等，因为基础镜像只需要下载一次即可共享，并不会造成太多的存储空间浪费。它的好处是这些镜像的生态比较完整，方便我们调试。

### 2、优化 apt-get 相关操作

将多个 apt-get 操作合并成一个，在 apt-get install 之前，先 apt-get update ,安装完成后最好使用 apt-get clean 清理一下。在使用 apt-get install 安装软件时，最好是按照字母排列，这样方便查找。

### 3、动静分离

经常变化的内容和基本不会变化的内容要分开，把不怎么变化的内容放在下层，创建出来不同基础镜像供上层使用。比如可以创建各种语言的基础镜像， `python2.7`、`python3.5`、`go1.7`、`java7`等等，这些镜像包含了最基本的语言库，每个组可以在上面继续构建应用级别的镜像。

### 4、最小原则：只安装必需的东西

很多人构建镜像时，会将可能用到的东西都打包到镜像中。必须要遏制这种想法，镜像中应该***只包含必需的东西***，任何可以有也可以没有的东西就不需要放在里面了。因为镜像的扩展很容易，而且运行容器的时候也很方便地对其进行修改。这样可以保证镜像尽可能的小，构建的时候尽可能的快，也保证未来的更快传输、更省网络资源。

### 5、使用更少的层

虽然看起来把不同的命令尽量分开来，写在多个命令中容易阅读和理解。但是这样会导致出现太多的镜像层，从而不好管理和分析镜像，而且镜像的层是有限的。尽量把内容相关的内容放到同一个层，使用换行符进行分割，这样可以进一步减小镜像大小，并且方便查看镜像历史。

### 6、减少每层的内容

尽管只安装必须的内容，在这个过程中也可能会产生额外的内容或者临时文件，我们要尽量让每层安装的东西保持最小。
	- 比如使用 `--no-install-recommends` 参数告诉 `apt-get` 不要安装推荐的软件包
	- 安装完软件包，清除 `/var/lib/apt/list/` 缓存
	- 删除中间文件：比如下载的压缩包，或者是只用了一次的软件包
	- 删除临时文件：如果命令产生了临时文件，也要及时删除

### 7、不要在 `Dockerfile` 中修改文件的权限

因为 `docker` 镜像是分层的，任何修改都会新增一个层，修改文件或者目录权限也是如此。如果修改大文件或者目录的权限，会把这些文件复制一份，这样很容易导致镜像很大。<br>
解决方案也很简单，要么在添加到 `Dockerfile` 之前就把文件的权限和用户设置好，要么在容器启动脚本(**entrypoint**)中做些修改。

### 8、利用 `cache` 来加快构建速度

如果 `Docker` 发现某个层已经存在了，它会直接使用已经存在的层，而不会重新运行一次。如果你连续运行 `docker build` 多次，会发现第二次运行很快就结束了。<br>
不过从 `1.10` 版本开始， Content Adrressable Stroage 的引入导致缓存功能的失效，目前引入了 `--cache-from` 参数可以手动指定一个镜像来使用它的缓存。

### 9、版本控制和自动构建

最好把 `Dockerfile` 和对应的应用代码一起放到版本控制中，然后能够自动构建镜像。这样的好处是可以追踪各个版本镜像的内容，方便了解不同镜像有什么区别，对于调试和回滚都有好处。<br>
另外，如果运行镜像的参数或者环境变量很多，也要有对应的文档给予说明，并且文档要随着 `Dockerfile` 变化而更新，这样任何人都能参考这文档很容易地使用镜像，而不是下载了镜像不知道如何使用。


# Dockerfile 写法中的注意事项

- CMD 和 ENTRYPOINT

```
CMD foo a b c
```

```
CMD ["foo", "a", "b", "c"]
```

尽量选择第二种写法

### 合理使用 ADD 命令

1、ADD 命令和 COPY 命令在很大程度上功能是一样的，但是 COPY 语义更加直接。但是唯一例外的是 ADD 命令自带解压功能，如果需要拷贝并解压一个文件到镜像中，我们可以使用 ADD 命令，除此之外，推荐使用 COPY。<br>
2、如果是使用 ADD 命令来获取网络资源，是不推荐的。网络资源应该使用 RUN wget 或者 curl 命令来获取。
